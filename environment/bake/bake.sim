/* 
	Copyright (c) 2018 Azeez Adewale <azeezadewale98@gmail.com> 
	MIT License Copyright (c) 2018 SIMPLE

*/

/* 
 * @Filename - bake.sim
 * @Author - Azeez Adewale
 * @Date - 08 April 2018
 * @Time - 02:56 AM
 */
 
 /*
		BAKE
		This program is is use for building distributable program
		written in simple to allow application or program written
		in simple to run on client or consumer computer without the 
		need of installing SIMPLE. The program generate executable
		that is runnable per Operating System build.
			Basically this program build your simple source to the 
		platform compatible. The outline below shows the currently 
		supported OS builds
		-----------------------------------
		| WINDOWS         |   .exe        |
		| MAC             |   .app        |
		| LINUX           |   ./program   |
		-----------------------------------
		
		COMMAND OPTIONS
		
			-F/</path>	specify the folder to place the program file
			-N/<name>	specify the output name of the program with no extension
			-I/icon		build your program with indicated icon
			-/h 		display this help note
			-temp -t	leave generated and temporary files after build
			-delete -del	delete the simple source file after successful build
			-debug		when the simple.h file is at ../../simple/src/includes/simple.h
			-S/<simple.h> Indicate the path to simple.h
			
			(Compiler Option) ~ if none is supplied the available will be used
			-mingw		use mingw compiler on windows
			-cygwin		use cygwin compiler on windows
			-vs 		use available Visual Studio build tools on windows
		
		
 */
 
 
 
call simple.utilities.Conversion
call simple.io.File
call simple.io.Directory
call simple.core.String
call simple.system.System
call simple.system.SimpleX
call simple.utilities.Console

Bakefile = null
final bakkrey = new Bakkery

/*

Parse "Bakefile"
*/
block main()
	header()
	bread = new Bread
	bread.SourceLang = "simple"
	
	params = cmdparams
	paramsLen = lengthOf(params) - 1
	if paramsLen < 0 { help() }
	for a = 0 to paramsLen {
		param = params[a]
		if param == "-f" {
			if a < paramsLen {
				Bakefile = params[a++]
				#parse bakefile
			else
				throw("bake","Expecting a Bakefile after the -f flag")
			}
		elif param == "-s" or param == "--static"
			bread.LinkStatically = true
			bread.LibraryExt = ".a"
			
		elif param == "-k" or param == "--keep"
			bread.KeepTemp = true
			
		elif param == "-g" or param == "--gui"
			bread.GUI = true
			
		elif param == "-z" or param == "--no-gui"
			bread.GUI = false
			
		elif param == "-x" or param == "--install"
			bread.Install = true
			
		elif strStartsWith(param,"-i=") or strStartsWith(param,"--icon=")
			iconPath = removeStr(param, "-i=")
			iconPath = removeStr(param, "--icon=")
			if iconPath != "" {
				bread.IconPath = iconPath
			}
			
		elif param == "-m" or param == "--mobile"
			bread.MobileOnly = true
			bread.BuildAll = false
			
		elif strEndsWith(param, ".sim")
			bread.SourceFile = new File(param)
			
		elif param == "x64"
			bread.BuildArch = "-m64"
			
		elif param == "x86"
			bread.BuildArch = "-m32"
			
		elif param == "-h" or param == "--h"
			help()
		}
	}
	
	if isNull(bread.SourceFile) {
		throw("bake", "A simple source file (.sim) is not provided")
	}
	if bread.SourceFile.Exists {
		bread.Name = bread.SourceFile.NameOnly
		bread.TempPath = new Directory(bread.SourceFile.Directory.AbsolutePath + bread.Name + "/tmp/")
		if !bread.TempPath.Exists {
			stdout.print("\rcreating temp working directory...")
			bread.TempPath.create()
		}
		if bakkrey.Verbose {
			stdout.print("\nsimple -s "+bread.SourceFile.AbsolutePath+"")
		}
		system("simple -s "+bread.SourceFile.AbsolutePath+"")
		complexPath = bread.SourceFile.Directory.AbsolutePath+"/"+bread.SourceFile.NameOnly+".complex"
		bread.SourceFile = new File(complexPath)
		bread.SourceFile.moveTo(bread.TempPath.AbsolutePath,true)
		bread.TempPath = bread.TempPath.AbsolutePath
		bakkrey.bake(bread)
	else
		throw("bake","the " + bread.SourceLang + " source file '" + bread.SourceFile.Name + "' does not exists")
	}

block header() 
	header = "bake 0.0.2 (December 27 2018, 09:03 PM)\nsimple " + simpleVersion()
	stdout.println(header)
	
block help()
	help = 
"usage:  bake [Bakefile] [OPTIONS] [ENV_VARS]

[Bakefile] : the Bakefile that contains building instructions
[OPTIONS] : option passed to the program.
[ENV_VARS] : change environment variables in Bakefile

The OPTIONS include: 
 -f --file		provide a Bakefile
 -h --help		print this help and exit
 -g --gui		mark build as GUI to remove terminal on startup
 -z --no-gui		mark build as Console base to show terminal on startup
 x64 --64-bits		mark all build for 64 bits arc
 x86 --32-bits		mark all build for 32 bits arc
 -i --icon=<iconpath>	build executable with icon
"
	stdout.println(help)
	__exit__
	
class Bread 

	SourceFile = null
	Name = null
	SourceLang = null
	TempPath = null
	IconPath = null
	BuildAll = true
	LinkStatically = false
	LibraryExt = "." + dynamicModuleExt()
	KeepTemp = false
	IsGui = false
	IsDebug = false
	BuildArch = "-m32"
	MobileOnly = false
	CFLAG = ""
	GUI = false
	Install = false

class Bakkery

	Verbose = false

	block bake(Bread bread)
		stdout.print("\rpreparing to bake " + bread.Name)
		stdout.print("\rcreating wrapper code for : " + bread.Name + "...")
		
		cCode = writeWrapper(bread)
		tempFile = new FileWriter(bread.TempPath+"/"+bread.Name+".bake.c", false, true)
		tempFile.write(cCode)
		tempFile.close()
		stdout.print("(done)")
		if !isNull(bread.IconPath) {
			createIcon(bread)
		}
		buildExecutables(bread)
		if bread.Install {
			installExecutable(bread)
		}
		if !bread.KeepTemp {
			removeTemps(bread)
		}
		
	private
	
		block writeWrapper(Bread bread)
			cCode = '#include {INCLUDE_FILE}

int main( int argc, char *argv[]) {
	static const unsigned char sim_code[] = { {COMPLEX_HEX} };
	SimpleState *sState ;
	sState = init_simple_state();
	sState->argc = argc ;
	sState->argv = argv ;
	simple_execute_object(sState, (char *) sim_code, "{FILE_NAME}");
	finalize_simple_state(sState);
}'
			cCode = replaceStr(cCode, "{FILE_NAME}", bread.Name + ".sim")
			cCode = replaceStr(cCode, "{COMPLEX_HEX}",__string_to_chex(bread.SourceFile.readAllString()))
			if isWindows() {
				cCode = replaceStr(cCode, "{INCLUDE_FILE}", '"'+simpleIncludesDir()+'/simple.h"')
				if bread.GUI {
					cCode = replaceStr(cCode, "int main( int argc, char *argv[]) {", 'int WINAPI WinMain ( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd ) { int argc ; char **argv ; argc = __argc ; argv = __argv ; ')
				}
			else
				cCode = replaceStr(cCode, "{INCLUDE_FILE}", "<simple/simple.h>")
			}
			
			return cCode
			
		block createIcon(bread)
			stdout.printf("\n\rpreparing icon file...")
			if isWindows() {
				stdout.printf("\r%s\rpreparing icon file : creating resources file...", strCopy(" ", 20))
				tempFile = new FileWriter(bread.TempPath+"/"+bread.Name+".bake.rc", false, true)
				tempFile.write('MAINICON ICON "' + bread.IconPath + '"')
				tempFile.close()
				stdout.printf("\r%s\rpreparing icon file : compiling resources file...", strCopy(" ", 20))
				arch = "pe-x86-64"
				if bread.BuildArch == "-m32" {
					arch = "pe-i386"
				}
				cmd = 'windres ' + bread.TempPath+"/"+bread.Name+".bake.rc" + ' -F '+arch+' -O coff -o ' + bread.TempPath+"/"+bread.Name+".bake.res"
				system(cmd)
				bread.CFLAG += " "+bread.TempPath+"/"+bread.Name+".bake.res "
			} 
			stdout.print("(done)")
			
		block buildExecutables(bread) 
			stdout.print("\n\rpreparing to build executables...")
			if isLinux() and bread.BuildAll {
				stdout.printf("\r%s\rbuilding for linux...", strCopy(" ", 40))
				__mkdir(bread.TempPath+"/../linux/",0755)
				cmd = 'cc '+bread.CFLAG+' '+bread.BuildArch+' -I/$DESTDIR/$PREFIX/include/ -I/usr/include/ -lm -ldl -o "'+bread.TempPath+"/../linux/"+bread.Name+'" "'+bread.TempPath+"/"+bread.Name+".bake.c"+'" '+simpleExecDir()+'../lib/libsimple' + bread.LibraryExt
				system(cmd)
				stdout.print("(done)")
				
			elif isWindows() and bread.BuildAll
				stdout.printf("\r%s\rbuilding for windows : compiling object code...", strCopy(" ", 40))
				cmd = 'gcc '+bread.BuildArch+' -c -g -MMD -MP -MF "' + bread.TempPath+"/"+bread.Name+".bake.c" + '.o.d" -o "' + bread.TempPath+"/"+bread.Name+".bake.c" + '.o" "'+bread.TempPath+"/"+bread.Name+".bake.c"+'"'
				system(cmd)
				__mkdir(bread.TempPath+"/../windows/",0755)
				__mkdir(bread.TempPath+"/../windows/",0755)
				if bread.GUI {
					bread.CFLAG += " -mwindows "
				}
				stdout.printf("\r%s\rbuilding for windows : generating executable...", strCopy(" ", 40))
				cmd = 'gcc '+bread.CFLAG+' '+bread.BuildArch+' -o "'+bread.TempPath+"/../windows/"+bread.Name+'.exe" "'+bread.TempPath+"/"+bread.Name+".bake.c"+'.o" '+simpleExecDir()+"/libsimple" + bread.LibraryExt
				system(cmd)
				stdout.print("(done)")
				
			elif isMacosx() and bread.BuildAll
				stdout.printf("\r%s\rbuilding for macosx...", strCopy(" ", 40))
				
				stdout.print("(done)")
			}
			
			if bread.BuildAll or bread.MobileOnly {
				
			}
			#stdout.print("\rbuilding for desktop..." + simpleExecDir)
			
		block installExecutable(bread)
			stdout.printf("\n\rinstalling "+bread.Name+'...')
			if isLinux() and bread.BuildAll {
				stdout.printf("\r%s\rinstalling "+bread.Name+' : detecting build directory...', strCopy(" ", 30))
				if __dir_exists(bread.TempPath+"/../linux/") {
					stdout.printf("\r%s\rinstalling "+bread.Name+' : detecting built executable...', strCopy(" ", 30))
					if __file_exists(bread.TempPath+"/../linux/"+bread.Name+'') {
						stdout.printf("\r%s\rinstalling "+bread.Name+' : copying built executable...', strCopy(" ", 33))
						__rename(bread.TempPath+"/../linux/"+bread.Name+'', exeFolder()+bread.Name+'')
						stdout.print("(done)")
					else
						stdout.printf("\r%s\rinstalling "+bread.Name+' : cannot detect built executable...(failed)', strCopy(" ", 33))
					}	
				else 
					stdout.printf("\r%s\rinstalling "+bread.Name+' : cannot detect build directory...(failed)', strCopy(" ", 33))
				}
			elif isWindows() and bread.BuildAll
				stdout.printf("\r%s\rinstalling "+bread.Name+'.exe : detecting build directory...', strCopy(" ", 33))
				if __dir_exists(bread.TempPath+"/../windows/") {
					stdout.printf("\r%s\rinstalling "+bread.Name+'.exe : detecting built executable...', strCopy(" ", 33))
					if __file_exists(bread.TempPath+"/../windows/"+bread.Name+'.exe') {
						stdout.printf("\r%s\rinstalling "+bread.Name+'.exe : copying built executable...', strCopy(" ", 37))
						__rename(bread.TempPath+"/../windows/"+bread.Name+'.exe', exeFolder()+bread.Name+'.exe')
						stdout.print("(done)")
					else
						stdout.printf("\r%s\rinstalling "+bread.Name+'.exe : cannot detect built executable...(failed)', strCopy(" ", 33))
					}	
				else 
					stdout.printf("\r%s\rinstalling "+bread.Name+'.exe : cannot detect build directory...(failed)', strCopy(" ", 33))
				}
			elif isMacosx() and bread.BuildAll
			}
		
		block removeTemps(bread)
			stdout.printf("\n\rremoving temporary files and folders...")
			if bread.Install {
				dir = new Directory(bread.TempPath+"/../")
				dir.deleteRecursive()
			else
				dir = new Directory(bread.TempPath+"/")
				dir.deleteRecursive()
			}
			stdout.print("(done)")
 
#end new bake
depmodules = []
outputName = ""
sourceFile = null
filePath = ""
removeTemps = true
useMINGW = false useCygwin = false useVS = false
specifysavepath = false specifyname = false
folder = "" name = "" isgui = false hasicon = false 
cflags = "" deletesim = false icon = "" isdebug = false
hassimpleh = false 
simpleh = ""
buildsucced = false

buildArch = "-m32"

#Program dependencies
simpleLibPath = "" simpleDllPath = "" simpleHPath = ""
sSharedLib = exeFolder()+'../lib/libsimple.so'
setDepLocation('../bin/')

block magin() header() 
	cmdParameters = cmdparams
	cmdlen = lengthOf(cmdParameters) - 1
	for a = 0 to cmdlen 
		if a = cmdlen && cmdlen >= 1 
			if strEndsWith(cmdParameters[a],'help') or strEndsWith(cmdParameters[a],'/h') help() end 
			filePath = cmdParameters[a]
			sourceFile = new File(cmdParameters[a])
		else
			if (strStartsWith(cmdParameters[a],'-'))
				if cmdParameters[a] == "--help" or cmdParameters[a] == "-h" help() 
				elif strStartsWith(toUpperCase(cmdParameters[a]),'-N/') specifyname = true name = removeStr(cmdParameters[a],"-N/")
				elif strStartsWith(toUpperCase(cmdParameters[a]),'-F/') specifysavepath  = true folder = removeStr(cmdParameters[a],"-F/")
				elif strStartsWith(toUpperCase(cmdParameters[a]),'-I/') hasicon  = true icon = removeStr(cmdParameters[a],"-I/")
				elif strStartsWith(toUpperCase(cmdParameters[a]),'-S/') hassimpleh  = true simpleh = removeStr(cmdParameters[a],"-S/")
				elif strEndsWith(cmdParameters[a],'mingw') useMINGW = true 
				elif strEndsWith(cmdParameters[a],'cygwin') useCygwin = true 
				elif strEndsWith(cmdParameters[a],'vs') useVS = true 
				elif strEndsWith(cmdParameters[a],'gui') isgui = true 
				elif strEndsWith(cmdParameters[a],'debug') or strEndsWith(cmdParameters[a],'d') isdebug = true setDepLocation('')
				elif strEndsWith(cmdParameters[a],'delete') || strEndsWith(cmdParameters[a],'del') if isWindows() deletesim = true end 
				elif strEndsWith(cmdParameters[a],'temp') or strEndsWith(cmdParameters[a],'t')  removeTemps = false 
				//tested
				elif cmdParameters[a] == "--lib" or cmdParameters[a] == "-l"  sSharedLib = cmdParameters[a++]
				elif cmdParameters[a] == "--32-bit" or cmdParameters[a] == "x86" or cmdParameters[a] == "-m32"  buildArch = "-m32"
				elif cmdParameters[a] == "--64-bit" or cmdParameters[a] == "x64" or cmdParameters[a] == "-m64" buildArch = "-m64"
				elif cmdParameters[a] == "--simpleh" or cmdParameters[a] =="-sh"  simpleHPath = '"'+cmdParameters[a++]+'"'
				else printError("Invalid option : "+cmdParameters[a]) end 
				__add_to_list(depmodules, cmdParameters[a]) 
			end
		end
	end
	if filePath = "" printError("No Simple/Complex file indicated ") end
	if outputName == "" 
		tempName = strAfterLast(filePath, '\')
		outputName = strAfterLast(tempName, '.')
		outputName = removeStr(tempName, '.'+outputName)
	end
	#display "params ========"+crlf display depmodules
	display "Input File : "+filePath+crlf
	display "Output Name : "+ outputName +crlf
	if not sourceFile.exists()
		printError("The File '"+filePath+"' does not exists")
	end
	writeCode()
	
block setDepLocation(location)
	simpleLibPath = '"'+exeFolder()+location+'libsimple.lib"' 
	simpleDllPath = '"'+exeFolder()+location+'libsimple.dll"' 
	simpleHPath = '"'+exeFolder()+location+'../include/simple/simple.h"'
	
block writeCode()
	display "Writing ANSI C Wrapper Code... "+crlf
	tCode = formatCode(sourceFile.readFileAsString())
	code = '
		/* 
		 * File:   bake.c
		 * Author: bake || Simple-lang executable file builder
		 * Description: Compile SIMPLE-LANG programs into standalone system executable files.
		 */
		'
			if isdebug code += '
			#include "../../simple/includes/simple.h" '+crlf
			else 
			code += '
			#include '+simpleHPath+' '+crlf end	
		if isWindows() and isgui 
			code += 'int WINAPI WinMain ( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd ) {
			int argc ; char **argv ; argc = __argc ; argv = __argv ; ' cflags+="-mwindows "
		else 
			code += 'int main( int argc, char *argv[]) {'
			
		end
		code += '	
		
			static const unsigned char sim_code[] = { '+__string_to_chex(sourceFile.readFileAsString())+'};
			
			List* list ; int x ;
			SimpleState *sState ;
			sState = create_instance();
			sState->argc = argc ; 
			sState->argv = argv ; 
			//hack around cmdparams 
			list = simple_state_newvar(sState,"cmdparams");
			simple_list_setint_gc(sState->vm->sState,list,SIMPLE_VAR_TYPE,SIMPLE_VM_LIST);
			simple_list_setlist_gc(sState->vm->sState,list,SIMPLE_VAR_VALUE);
			list = simple_list_getlist(list,SIMPLE_VAR_VALUE);
			for ( x = 0 ; x < sState->vm->sState->argc ; x++ ) {
					simple_list_addstring_gc(sState->vm->sState,list,sState->vm->sState->argv[x]);
			}
			//hack end
			execute_simple_object(sState, (char *) sim_code);
			finalize_simple_state(sState);
		}

' 
	tempFile = new File(filePath+".bake.c") 
	display "-->Writing obj code to "+tempFile.toString()+crlf
	tempFile.write(code)
	createExecutable(filePath+".bake.c")
	
block createExecutable(path)
	createIcon(path)
	if isWindows()
		display "--->Starting build : "+outputName+".exe"+crlf
		windowsBuild(path)
	elif isMacosx()
		
	elif isLinux() || isUnix()
		display "--->Starting build : "+outputName+""+crlf
		linuxBuild(path)
	end

	 
block windowsBuild(path) 
	mingwBuildTool = new File("C:\MinGW64\bin\gcc.exe")
	cygwinBuildTool = new File("C:\cygwin\bin\gcc.exe")		
	#check if system has mingw
	if useMINGW
		windowBuildMingw(mingwBuildTool,path)
	elif useCygwin
		
	elif useVS
		display simpleLibPath
		windowBuildVS(path)
	else
		display "No Build tool specified using available build tools"+crlf
		if mingwBuildTool.exists() 
			display mingwBuildTool.toString()+" --> MINGW Build Tool Detected"+crlf
			windowBuildMingw(mingwBuildTool,path)
		elif cygwinBuildTool.exists()
		#check if system has cygwin
			display "--> CYGWIN Build Tool Detected"+crlf
			display "--> Building Executable with CYGWIN"+crlf
		else
			display " Resolving to build using Visual Studio"+crlf
			windowBuildVS(path)
		end
	end
	
block creatseIcon(path)
	if hasicon and isWindows() 
		display "Creating your ICON dependencies files.."+crlf
		con = 'MAINICON  ICON  "'+icon+'"'
		tempFile = new File(path+".rc")  display "		Creating Resources file "+tempFile.toString()+crlf tempFile.write(con)
		con = 'windres '+tempFile.absolutePath()+' -O coff -o '+path+'.res'
		display "		Compiling Resources file "+tempFile.toString()+crlf system(con)
		cflags += path+'.res '
	end
	
block windowBuildVS(path)
	display "--> Building Executable with Visual Studio"+crlf cmd = ''
	for a = 1 to 16
		f = new File('C:\Program Files (x86)\Microsoft Visual Studio '+a+'.0\VC\vcvarsall.bat')
		if f.exists() display "		we found Visual Studio "+a+".0"+crlf 
		cmd = 'call "C:\Program Files (x86)\Microsoft Visual Studio '+a+'.0\VC\vcvarsall.bat" x86'+crlf
		end
	end
	cmd += "cl /Fo.\.\ /Fe.\.\ /GA /MT "+path+" "+simpleLibPath #simple.lib link to actual location
	display cmd + crlf 
	tempFile = new File(path+".bat")  display "		Create batch file "+tempFile.toString()+crlf tempFile.write(cmd)
	display "		Executing build command " + crlf system(tempFile.toString())
	fi = new File(filePath+".bake.exe") if fi.exists() fi.renameTo(outputName+".exe") end 
	cleanTempFiles([removeStr(path, ".c")+".obj",path+".bat",path]) treatProgramAttr()
	
block windowBuildMingw(mingwBuildTool,path)
	display "--> Building Executable with MINGW"+crlf
	exeCmd = mingwBuildTool.absolutePath()+' -c -g -MMD -MP -MF "'+path+'.o.d" -o "'+path+'.o" "'+path+'"'
	display "		Executing compilation command "/*+exeCmd */+ crlf system(exeCmd) 
	exeCmd = mingwBuildTool.absolutePath()+' '+cflags+' -o "'+outputName+'.exe" "'+path+'.o" '+simpleDllPath
	display "		Executing build command " + crlf system(exeCmd) 
	cleanTempFiles([path,path+".o.d",path+".o",path+'.rc',path+'.res']) treatProgramAttr()

block linuxBuild(path)
	/* link at runtime */
	#cmd = 'cc -I/$DESTDIR/$PREFIX/include "-Wl,--no-as-needed" -lm -ldl -o "'+outputName+'" "'+path+'" '+' -Lsimple.so'
	/* link at build time */
	LDFLAG = '-L ./ -Wl,-R../lib/ "-Wl,-rpath,./ ../lib/ /usr/lib/ /lib/ /usr/local/lib/ ~/lib/" "-Wl,--no-as-needed"'
	cmd = 'cc '+buildArch+' -I/$DESTDIR/$PREFIX/include/ -I/usr/include/ '+LDFLAG+' -lm -ldl -o "'+outputName+'" "'+path+'" '+sSharedLib
	#cmd = 'cc "-Wl,--no-as-needed" -lm -ldl -o "'+outputName+'" "'+path+'" '+' '+exeFolder()+'simple.so'
	#cmd = 'cc -fpic -g -lm -ldl -o '+outputName+" "+path+' "-Wl,--no-as-needed" "'+exeFolder()+'simple.so"'
	display cmd + crlf
	display "		Executing compilation command "/*cmd */+ crlf
	display "		Executing build command "/*cmd */+ crlf
	display cmd + crlf
	system(cmd)
	treatProgramAttr()  cleanTempFiles([path,path+".o"]) 
	
block treatProgramAttr() 
	if specifyname
		display "Renaming "+outputName+".exe to "+name +".exe"+ crlf
		f = new File(outputName+".exe") display f.absolutePath()+crlf 
		f.renameTo(removeStr(outputName,strAfterLast(curePathSlashes(outputName),'\'))+name+".exe")
		outputName = removeStr(outputName,strAfterLast(curePathSlashes(outputName),'\'))+name
	end
	if specifysavepath 
		display "Moving "+outputName+" to "+folder + crlf
		if isWindows() 
			system("move "+outputName+'.exe '+folder+"/")
		elif isLinux()
			f = new File(outputName)
			#if f.exists() { f.delete() }
			f.moveTo(folder)
		else
		
		end
	end
	
	
block cleanTempFiles(tempfiles)
	if removeTemps 
		display "		Cleaning up temporary files... "+crlf 
			tlen = lengthOf(tempfiles) - 1
		for a = 0 to tlen
			display "	Deleting : "+tempfiles[a]+crlf
			file = new File(tempfiles[a]) if file.exists() file.delete() end
		end
	end  
	if deletesim display "	Deleting : "+sourceFile.name()+crlf sourceFile.delete() end
	
	
#This block is temporal until simple compiler @Bold simplify @EndBold
#It current usefulness is to clean and format the source code of 
#the simple file to enable it fit into the string quote i.e to make it 
#conform into the standard string in a C source file
block formatCode(code)
	#code = ''+replaceString(code, '"', '\"')
	#code = replaceString(code, ascii(10), '					"')
	finalCode = '"'
	display "->formating the simple source code (TEMP)"+crlf
	lineLen =lengthOf(code) - 1
	for a = 0 to lineLen
		if code[a] == '"'
			finalCode+= '\"'
		elif code[a] == '\'
			finalCode+= '\\'
		elif code[a] == ascii(13) #end of line
			finalCode+= '"'
		elif code[a] == ascii(10) #line break
			finalCode+= crlf+'" '
		else 
			finalCode+= code[a]
		end
	end
	return finalCode+'"'
	
block formatString(value)
	vlen = lengthOf(value) - 1
	value+= 'xs'
	display value
	return value
				
block help()
	display "This program is use to build simple source to platform executable
Usage:  bake ([OPTIONS]) [PATH]
	
The OPTIONS include :
	-F/</path>	specify the folder to place the program file
	-N/<name>	specify the output name of the program with no extension
	-I/icon		build your program with indicated icon
	-help 		display this help note
	-temp -t	leave generated and temporary files after build
	-delete -del	delete the simple source file after successful build
	-debug		when the simple.h file is at ../../simple/src/includes/simple.h
	-S/<simple.h>	Indicate the path to simple.h
	
	(Compiler Option) ~ if none is supplied the available will be used
	-mingw		compile with mingw toolchain on windows
	-cygwin		compile with cygwin compiler on windows
	-vs 		use available Visual Studio build tools on windows
	
	(Architecture Option) ~ x86 is the default
	-x86 		use 32 bit compiler for the build
	-x64 		use 64 bit compiler for the build
======================================================="
	__exit__

block printError(msg)
	display "BAKE : "+msg + crlf
	display "======================================================="+crlf
	__exit__
	
	
/*
	BUG MAP 
	-------------------
	001 - the source file should not be gotten first


*
	
	
	
	
	
	
	
	
	
	
	
	
	

module simple.io call "Path.sim" call "File.sim" block mkdir(path) __mkdir(path) class Directory :Path __IO_DIRECTORY_EXISTS ="The directory already exists you should remove the directory first" __IO_MODULE ="simple.io.Directory" __IO_DIRECTORY__NOT_EXISTS ="The directory does not exists" __IO_DIRECTORY_DELETE ="The directory cannot be deleted" __IO_DIRECTORY_PATH ="" __IO_DIRECTORY_INVALID_PARAMETER ="Invalid parameter, expected Path, String or Directory" block Directory(path) updateAttributes(path) block create() ensureParent() return mkdir(__IO_DIRECTORY_PATH) block explode() return blow_dir(__IO_DIRECTORY_PATH) block listFiles() eDir =explode() for a =0 to lengthOf(eDir) if !eDir[a][2] nFile =new File(__IO_DIRECTORY_PATH+getSystemSlash()+eDir[a][1]) add(filesList,nFile) end end return filesList block listDirectories() eDir =explode() for a =0 to lengthOf(eDir) if eDir[a][2] nDir =new Directory(__IO_DIRECTORY_PATH+getSystemSlash()+eDir[a][1]) add(folderList,nDir) end end return folderList block toPath() return new Path(__IO_DIRECTORY_PATH) block getPath() return absolutePath() block toString() return rawDirectoryPath block parent() parentDir =parentPath().toDirectory() return new Directory(parentDir) block addChild(dir) add(childrenToCreate,dir) block getPendingChildern() return childrenToCreate block getName() return directoryName block delete() if exists(){ if isWindows(){ __exec('rmdir /S /Q "'+__IO_DIRECTORY_PATH+'" 2> nul') elif isLinux() __exec('rm -rf "' +__IO_DIRECTORY_PATH+'"') else}} if exists(){ return false else return true} return __delete_directory(getPath()) block deleteFolderRecursively(tempFolder,typeBool) filesStack =tempFolder.listFiles() filesStackLength =lengthOf(filesStack) if !typeBool { for i =0 to filesStackLength { __delete(filesStack[i].absolutePath())} folderStack =tempFolder.listDirectories() folderStackLength =lengthOf(folderStack) for a =0 to folderStackLength { add(__IO_DIRECTORY_TEMP_DIRECTORIES,folderStack[a].getPath()) deleteFolderRecursively(folderStack[a],typeBool)} else tempFoldersListLength =lengthOf(__IO_DIRECTORY_TEMP_DIRECTORIES) for b =tempFoldersListLength to 0 step -1 { if !__delete_directory(__IO_DIRECTORY_TEMP_DIRECTORIES[b]){ add(__IO_DIRECTORY_TEMP_DIRECTORIES_2,__IO_DIRECTORY_TEMP_DIRECTORIES[b])}}} block formatDirectoryName(dir) while (stringEndsWith(dir,getSystemSlash())){ dir =removeStringAt(dir,lengthOf(dir))} dName =lastStringAfterChar(dir,getSystemSlash()) return dName  block exists() tempPath =new Path(__IO_DIRECTORY_PATH) return tempPath.isADirectory() block renameTo(newName) if !isString(newAbsoluteName){ throwWithTitle(__IO_MODULE,newAbsoluteName+" - "+__IO_PATH_NOT_STRING)} tempPath =new Path(newName) if tempPath.exists(){ throwWithTitle(__IO_MODULE,tempPath.toString()+" - "+__IO_DIRECTORY_EXISTS)} renameValue =_renameTo(__IO_DIRECTORY_PATH,tempPath.toString()) if renameValue { updateAttributes(tempPath.toString())} return renameValue block forceRenameTo(newName) if !isString(newName){ throwWithTitle(__IO_MODULE,newName+" - "+__IO_PATH_NOT_STRING)} tempDir =new Directory(newName) if tempDir.exists(){ warn(__IO_MODULE+" : "+tempDir.getPath()+" - "+__IO_PATH_EXISTS_DELETE) if tempDir.delete()!=true { throwWithTitle(__IO_MODULE,tempDir.getPath()+" - "+__IO_DIRECTORY_DELETE)}} renameValue =_renameTo(__IO_DIRECTORY_PATH,tempDir.getPath()) if renameValue { updateAttributes(tempDir.getPath())} return renameValue block moveTo(newFolder) return _moveTo(newFolder,false) block forceMoveTo(newFolder) return _moveTo(newFolder,true) block _moveContentTo(destFolder,moveType) tempDestFolder =destFolder if isString(destFolder){ tempDestFolder =new Directory(destFolder) elif isPath(destFolder) tempDestFolder =new Directory(destFolder.toString()) elif !isDirectory(destFolder) throwWithTitle(__IO_MODULE,destFolder+" - "+__IO_DIRECTORY_INVALID_PARAMETER)} if !tempDestFolder.exists(){ if moveType { tempDestFolder.create() else throwWithTitle(__IO_MODULE,destFolder+" - "+__IO_DIRECTORY__NOT_EXISTS)}} filesListLength =lengthOf(listFiles()) for a =0 to filesListLength { if moveType { filesList[a].forceMoveTo(tempDestFolder) else filesList[a].moveTo(tempDestFolder)}} folderListLength =lengthOf(listDirectories()) for a =0 to folderListLength { if moveType { folderList[a].forceMoveTo(tempDestFolder.getPath()) else folderList[a].moveTo(tempDestFolder.getPath())}} block moveContentTo(destFolder) _moveContentTo(destFolder,false) block forceMoveContentTo(destFolder) _moveContentTo(destFolder,true) private __IO_DIRECTORY_TEMP_DIRECTORIES =[] rawDirectoryPath ="" directoryName ="" filesList =[] folderList =[] childrenToCreate =[] block ensureParent() tempDir =__IO_DIRECTORY_PATH if stringEndsWith(__IO_DIRECTORY_PATH,__IO_PATH_SYSTEM_SLASH){ tempDir =removeLastChar(tempDir)} tempDir =removeString(tempDir,lastStringAfterChar(tempDir,__IO_PATH_SYSTEM_SLASH)) pd =new Directory(tempDir)pd.addChild(__IO_DIRECTORY_PATH) if (!pd.exists())pd.create()else mkdir(pd.getPendingChildern()[0])end block updateAttributes(path) if isPath(path) __IO_DIRECTORY_PATH =path.toString() else  __IO_DIRECTORY_PATH =path rawDirectoryPath =path end __IO_DIRECTORY_PATH =curePathSlashes(__IO_DIRECTORY_PATH) directoryName =formatDirectoryName(__IO_DIRECTORY_PATH) if !stringEndsWith(__IO_DIRECTORY_PATH,__IO_PATH_SYSTEM_SLASH){ __IO_DIRECTORY_PATH+=__IO_PATH_SYSTEM_SLASH} __IO_PATH =__IO_DIRECTORY_PATH